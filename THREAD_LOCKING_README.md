# Система блокировки тредов OpenAI

## Проблема

Ранее в системе была глобальная блокировка на уровне всего API OpenAI, что приводило к следующим проблемам:

1. **Блокировка разных пользователей**: Если один пользователь отправлял запрос, все остальные пользователи ждали его завершения
2. **Неэффективное использование ресурсов**: Разные треды не могли работать параллельно
3. **Отсутствие защиты от дублирования**: В один тред можно было отправить несколько запросов одновременно

## Решение

Реализована система блокировки на уровне **отдельных тредов**, которая позволяет:

✅ **Разным тредам работать параллельно** - каждый тред блокируется независимо  
✅ **Разным пользователям не ждать друг друга** - каждый пользователь имеет свой тред  
✅ **Предотвращать дублирование запросов** - в один тред нельзя отправить новый запрос, пока не завершился предыдущий  
✅ **Автоматическая очистка блокировок** - даже при ошибках тред разблокируется  

## Как это работает

### 1. Отслеживание активных тредов

```typescript
private activeThreads: Map<string, Promise<any>> = new Map();
```

Каждый тред (по `threadId`) может быть либо свободен, либо занят выполнением запроса.

### 2. Блокировка треда

```typescript
private async lockThread<T>(threadId: string, operation: () => Promise<T>): Promise<T> {
  if (this.isThreadActive(threadId)) {
    throw new Error('Тред уже занят другим запросом. Пожалуйста, дождитесь завершения предыдущего запроса.');
  }

  const promise = operation();
  this.activeThreads.set(threadId, promise);
  
  try {
    const result = await promise;
    return result;
  } finally {
    this.activeThreads.delete(threadId); // Автоматическая разблокировка
  }
}
```

### 3. Проверка активности треда

```typescript
private isThreadActive(threadId: string): boolean {
  return this.activeThreads.has(threadId);
}
```

### 4. Ожидание завершения активных runs

```typescript
private async checkAndWaitForActiveRuns(threadId: string): Promise<void> {
  const runs = await this.openAi.beta.threads.runs.list(threadId);
  const activeRun = runs.data.find(
    (run) => run.status === 'in_progress' || run.status === 'queued'
  );

  if (activeRun) {
    await this.waitForRunCompletion(threadId, activeRun.id);
  }
}
```

## Использование в методах

Все методы чата (`chat`, `chatWithImage`, `chatWithFile`) теперь используют систему блокировки:

```typescript
// Используем систему блокировки тредов
return await this.lockThread(threadId, async () => {
  // Проверяем активные runs в треде
  await this.checkAndWaitForActiveRuns(threadId);
  
  // Выполняем основную логику...
});
```

## Обработка ошибок

При попытке отправить запрос в занятый тред пользователь получает понятное сообщение:

```typescript
if (error instanceof Error && error.message.includes('Тред уже занят')) {
  return {
    text: '⏳ Тред уже занят другим запросом. Пожалуйста, дождитесь завершения предыдущего запроса.',
    files: [],
  };
}
```

## Мониторинг

Для отладки доступен метод получения статуса активных тредов:

```typescript
getActiveThreadsStatus(): { threadId: string; isActive: boolean }[]
```

## Примеры сценариев

### ✅ Сценарий 1: Разные пользователи работают параллельно
- Пользователь A отправляет запрос → тред A блокируется
- Пользователь B отправляет запрос → тред B блокируется  
- Оба запроса выполняются одновременно
- Результат: максимальная производительность

### ✅ Сценарий 2: Один пользователь, один тред
- Пользователь отправляет запрос → тред блокируется
- Пользователь отправляет второй запрос → получает ошибку "Тред уже занят"
- Результат: предотвращение дублирования

### ✅ Сценарий 3: Обработка ошибок
- Запрос выполняется → тред заблокирован
- Происходит ошибка → тред автоматически разблокируется
- Результат: система остается стабильной

## Тестирование

Система покрыта тестами, проверяющими:

- Параллельную работу разных тредов
- Блокировку дублирующих запросов
- Автоматическую очистку блокировок при ошибках
- Корректность статуса активных тредов

Запуск тестов:
```bash
npm test -- --testPathPattern=openai.service.spec.ts
```

## Преимущества новой системы

1. **Производительность**: Разные треды работают параллельно
2. **Изоляция**: Пользователи не блокируют друг друга
3. **Надежность**: Автоматическая очистка блокировок
4. **UX**: Понятные сообщения об ошибках
5. **Масштабируемость**: Система готова к росту нагрузки
